import { Injectable } from '@angular/core';
import { API, graphqlOperation } from 'aws-amplify';
import {
  cardsByRoomFull,
  stacksByRoomFull
} from 'src/graphql/customqueries';
import { onUpdateMoveable } from 'src/graphql/subscriptions';
import {
  CardsByRoomFullQuery,
  CardsByRoomQueryVariables,
  OnUpdateMoveableSubscription,
  UpdateMoveableMutationVariables,
  GetMoveableQuery,
  StacksByRoomQueryVariables,
  StacksByRoomFullQuery,

} from '../API.service';


import Observable from 'zen-observable-ts';
import { PlayerService } from './player.service';
import { RoomService } from './room.service';
import { updateMoveable } from 'src/graphql/mutations';
import { card, cardStack, moveable } from '../types';

@Injectable({
  providedIn: 'root'
})
export class MoveableService {

  private cards: card[];
  private stacks: cardStack[];
  private readonly lookup: { [key: string]: card | cardStack } = {}; // moveableId->flattened obj
  private inMotion: moveable[] = [];

  public readonly UPDATE_MIN_MS = 100;
  public readonly CARD_H = 105;
  public readonly CARD_W = 75;
  public readonly STACK_H = 105;
  public readonly STACK_W = 100;

  private maxZ = -1;

  constructor(
    private playerService: PlayerService,
    private roomService: RoomService

  ) {
    this.listStacks();
    this.listCards();

  }

  private async listStacks() {
    const listParams: StacksByRoomQueryVariables = {
      roomId: this.roomService.id
    };
    const resp = await API.graphql(graphqlOperation(stacksByRoomFull, listParams)) as { data: StacksByRoomFullQuery };
    const roomStacksResp = resp.data.stacksByRoom.items;

    this.stacks = roomStacksResp.map(el => {

      const moveableResp = this.respToLoc(el);
      const stackObj: cardStack = Object.assign({
        id: el.id,
        highlight: false,
        cards: []
      }, moveableResp);
      this.lookup[el.moveable.id] = stackObj;
      return stackObj;

    });
  }

  private async listCards() {
    const listParams: CardsByRoomQueryVariables = {
      roomId: this.roomService.id
    };
    const resp = await API.graphql(graphqlOperation(cardsByRoomFull, listParams)) as { data: CardsByRoomFullQuery };
    const roomCardsResp = resp.data.cardsByRoom.items;

    this.cards = roomCardsResp.map(el => {

      const moveableResp = this.respToLoc(el);
      const cardObj: card = Object.assign({
        id: el.id,
        faceUp: el.faceUp,
        cardValue: el.cardValue,
        highlight: false
      }, moveableResp);
      this.lookup[el.moveable.id] = cardObj;
      this.maxZ = Math.max(this.maxZ, cardObj.z);
      return cardObj;
    });

    const vars = {
      roomId: this.roomService.id,
    };
    // TODO: can this specific type be specified in autogenerated ts?
    // should be OnUpdateCardSubscription insteady of `any`
    const obs = API.graphql(graphqlOperation(onUpdateMoveable, vars)) as Observable<object>;

    obs.subscribe({
      next: (resp: { value: { data: OnUpdateMoveableSubscription } }) => {
        const updated = resp.value.data.onUpdateMoveable;
        const local = this.lookup[updated.id];

        const updateTime = (new Date(updated.updatedAt)).getTime();
        if (!local.inMotion
          && this.playerService.id !== updated.lastOwner
          && updateTime > local.lastUpdated) {
          const copyProps = {
            x: updated.x,
            y: updated.y,
            z: updated.z,
            lastOwner: updated.lastOwner,
            lastUpdateTime: updateTime
          };
          Object.assign(local, copyProps);
        }
      }
    });

  }

  // Stealing GetMoveableQuery as a general moveable type 
  // from the backend
  private respToLoc(el: { moveable: GetMoveableQuery['getMoveable'] }) {
    const resp: moveable = {
      //id: el.id,
      roomId: this.roomService.id,
      moveableId: el.moveable.id,
      x: el.moveable.x,
      y: el.moveable.y,
      z: el.moveable.z,
      inMotion: el.moveable.inMotion,
      lastUpdated: (new Date(el.moveable.updatedAt)).getTime(),
      lastOwner: el.moveable.lastOwner,
      draggable: true,
    }
    return resp;
  }

  private isCard(moveableIn: card | cardStack) {
    return 'cardValue' in moveableIn;
  }

  private isStack(moveableIn: card | cardStack) {
    return 'cards' in moveableIn;
  }

  public mouseMove(event: MouseEvent) {
    const curTime = (new Date()).getTime();
    this.inMotion.forEach(obj => {

      const x = event.x;
      const y = event.y;

      obj.x = Math.round(x - this.CARD_W / 2);
      obj.y = Math.round(y - this.CARD_H / 2);


      for (const card of this.cards) {
        this.updateHighlight(x, y, card);
      }
      for (const stack of this.stacks) {
        this.updateHighlight(x, y, stack);
      }


      if (curTime - obj.lastUpdated > this.UPDATE_MIN_MS) {

        obj.lastUpdated = curTime;
        const moveableParams: UpdateMoveableMutationVariables = {
          input: {
            id: obj.moveableId,
            x: obj.x,
            y: obj.y,
            z: obj.z,
            lastOwner: this.playerService.id,
            inMotion: obj.inMotion,
          }
        };
        API.graphql(graphqlOperation(updateMoveable, moveableParams));
      }
    });
  }

  private updateHighlight(mouseX: number, mouseY: number, moveableIn: cardStack | card) {
    const curHighlight = moveableIn.highlight;
    const nextHighlight = this.inMoveable(mouseX, mouseY, moveableIn);
    if (curHighlight !== nextHighlight) {
      moveableIn.highlight = nextHighlight;
    }
  }

  private inMoveable(mouseX: number, mouseY: number, moveableIn: cardStack | card) {
    const width = this.isCard(moveableIn) ? this.CARD_W : this.STACK_W
    const height = this.isCard(moveableIn) ? this.CARD_H : this.STACK_H
    return moveableIn.x < mouseX &&
      mouseX < moveableIn.x + width &&
      moveableIn.y < mouseY &&
      mouseY < moveableIn.y + height;

  }

  public mouseDown(id: string) {
    const moveableObj = this.lookupMoveable(id);
    moveableObj.inMotion = true;
    this.maxZ += 1;
    moveableObj.z = this.maxZ;
    this.inMotion.push(moveableObj);


  }

  public mouseUp() {

    if (this.inMotion.length > 1) {
      console.error('Not ready for this');
    } else if (this.inMotion.length === 1) {
      const inMotion = this.inMotion.pop();
    }


    for (const card of this.cards) {
      if (card.inMotion) {
        card.highlight = false;
      }
    }

    for (const stack of this.stacks) {
      stack.highlight = false;
    }

  }

  public beingDragged(id: string) {
    const moveableObj = this.lookupMoveable(id);
    return moveableObj.inMotion;
  }

  public getHeight(id) {
    const moveableObj = this.lookupMoveable(id);
    if (this.isCard(moveableObj)) {
      return this.CARD_H + 'px';
    } else if (this.isStack(moveableObj)) {
      return this.STACK_H + 'px';
    }
  }

  public getWidth(id) {
    const moveableObj = this.lookupMoveable(id);
    if (this.isCard(moveableObj)) {
      return this.CARD_W + 'px';
    } else if (this.isStack(moveableObj)) {
      return this.STACK_W + 'px';
    }
  }

  public getTransform(id) {
    const moveableObj = this.lookupMoveable(id);
    return `translate3d(${moveableObj.x}px, ${moveableObj.y}px, 0px)`;
  }

  public getZ(id) {
    const moveableObj = this.lookupMoveable(id);
    return moveableObj.z;
  }

  public isHighlighted(id) {
    const moveableObj = this.lookupMoveable(id);
    if (this.isCard(moveableObj) || this.isStack(moveableObj)) {
      const card = moveableObj as card | cardStack;
      return card.highlight;
    }
  }

  public getCards(): card[] {
    return this.cards;
  }

  public getStacks(): cardStack[] {
    return this.stacks;
  }

  private lookupMoveable(id): card | cardStack {
    return this.lookup[id];
  }



}

