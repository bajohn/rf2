

type Card @model 
 @auth (
    rules: [
      { allow: public, operations: [create, update, delete, read] }
    ]
  )
  @key(fields: ["roomId", "cardValue"])
  # @key(name: "cardComposite", fields: ["roomId", "cardValue"])
  # @key(name: "cardByRoom", fields: ["roomId"])
  {
  cardValue: ID!
  roomId: ID!
  x: Int!
  y: Int! 
  z: Int!
  faceUp: Boolean!
  lastOwner: ID!
}

type Room @model
 @auth (
    rules: [
      { allow: public, operations: [create, update, delete, read] }
    ]
  )
  @key(fields: ["roomId"])
  {
  roomId: ID!
  players: [Player] @connection(keyName: "playerByRoom", fields: ["roomId"])
  # cards: [Card] @connection(keyName: "cardByRoom", fields: ["roomId"])
}


type RoomUpdates {
  onCardMove: Card @aws_subscribe(mutations: ["updateCard"])
}



type Player @model
 @auth (
    rules: [
      { allow: public, operations: [create, update, delete, read] }
    ]
  )
  @key(name: "playerByRoom", fields: ["roomId", "playerId"], queryField: "playerbyRoom")
  {
  roomId: ID!
  playerId: ID!
  name: String!
}



# TODO: use query() to pull all the cards for only one game (via secondary index, @key decorator)
